import { PrismaClient } from '../generated/prisma/index.js';
import User from '../models/User.js';
import Loan from '../models/Loan.js';
import InterestRate from '../models/InterestRate.js';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory name
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const prisma = new PrismaClient();

// Helper function to delete old images for a user by phone number and image type
const deleteOldImages = async (phone, imageType) => {
  try {
    // Find user by phone number
    const user = await User.findOne({ phone });
    if (!user) return;
    
    // Determine which path to check based on image type
    let oldImagePath = null;
    switch (imageType) {
      case 'idCardFront':
        oldImagePath = user.idCardFrontUrl;
        break;
      case 'idCardBack':
        oldImagePath = user.idCardBackUrl;
        break;
      case 'selfieWithId':
        oldImagePath = user.selfieWithIdUrl;
        break;
      case 'signature':
        oldImagePath = user.signatureUrl;
        break;
    }
    
    // If there's an old image, delete it
    if (oldImagePath && fs.existsSync(oldImagePath)) {
      fs.unlinkSync(oldImagePath);
      console.log(`Deleted old image: ${oldImagePath}`);
    }
  } catch (error) {
    console.error('Error deleting old images:', error);
  }
};

// Helper function to save base64 image to file
const saveBase64Image = (base64Data, fileName, imageType) => {
  if (!base64Data) return null;
  
  // Determine the specific folder based on image type
  let specificFolder;
  switch (imageType) {
    case 'idCardFront':
      specificFolder = '_idCard_front';
      break;
    case 'idCardBack':
      specificFolder = '_idCard_back';
      break;
    case 'selfieWithId':
      specificFolder = '_idCard_selfie';
      break;
    case 'signature':
      specificFolder = '_signature';
      break;
    default:
      specificFolder = '';
  }
  
  // Create the base uploads directory if it doesn't exist
  const baseUploadDir = path.join(__dirname, '../../uploads');
  if (!fs.existsSync(baseUploadDir)) {
    fs.mkdirSync(baseUploadDir, { recursive: true });
  }
  
  // Create the specific folder if it doesn't exist
  const uploadDir = path.join(baseUploadDir, specificFolder);
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  }
  
  // Extract the base64 data (remove data:image/jpeg;base64, part)
  const matches = base64Data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
  if (!matches || matches.length !== 3) return null;
  
  const type = matches[1];
  const data = matches[2];
  const buffer = Buffer.from(data, 'base64');
  
  // Generate a unique filename
  const filePath = path.join(uploadDir, fileName);
  fs.writeFileSync(filePath, buffer);
  
  return filePath;
};

// Generate a unique application number
function generateApplicationNumber() {
  const timestamp = Date.now().toString();
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `LOAN-${timestamp}-${random}`;
}

// Save ID verification data (ID card front, back, selfie, and signature)
export const saveIdVerification = async (req, res) => {
  try {
    console.log('ID verification request received:', req.body);
    console.log('Files received:', req.files); // Log files for debugging
    
    const { phone } = req.body;
    
    // Validate phone number is provided
    if (!phone) {
      return res.status(400).json({
        status: 'error',
        message: 'Phone number is required'
      });
    }
    
    // Check if files or signature are attached (Multer puts files in req.files)
    if ((!req.files || Object.keys(req.files).length === 0) && !req.body.signature) {
      return res.status(400).json({
        status: 'error',
        message: 'No files or signature provided'
      });
    }
    
    // Find user by phone number
    let user = await User.findOne({ phone });
    
    if (!user) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found. Please complete the personal information step first.'
      });
    }
    
    // Process ID card front if provided
    let idCardFrontPath = null;
    if (req.files && req.files.idCardFront && req.files.idCardFront[0]) {
      // Delete old image if it exists
      await deleteOldImages(phone, 'idCardFront');
      
      // Save new image
      const file = req.files.idCardFront[0]; // Multer provides an array
      const nationalId = user.personalInformation?.nationalId || 'unknown';
      const fileName = `${nationalId}-front-${Date.now()}${path.extname(file.originalname)}`;
      
      // Get the directory for ID card front
      const uploadDir = path.join(__dirname, '../../uploads/_idCard_front');
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      
      // Move the file to the upload directory - Multer already saved the file, just get the path
      idCardFrontPath = file.path;
    } else if (req.body.idCardFront) {
      // Handle base64 image data
      const nationalId = user.personalInformation?.nationalId || 'unknown';
      idCardFrontPath = saveBase64Image(
        req.body.idCardFront,
        `${nationalId}-front-${Date.now()}.jpg`,
        'idCardFront'
      );
    }
    
    // Process ID card back if provided
    let idCardBackPath = null;
    if (req.files && req.files.idCardBack && req.files.idCardBack[0]) {
      // Delete old image if it exists
      await deleteOldImages(phone, 'idCardBack');
      
      // Save new image
      const file = req.files.idCardBack[0]; // Multer provides an array
      const nationalId = user.personalInformation?.nationalId || 'unknown';
      const fileName = `${nationalId}-back-${Date.now()}${path.extname(file.originalname)}`;
      
      // Get the directory for ID card back
      const uploadDir = path.join(__dirname, '../../uploads/_idCard_back');
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      
      // Multer already saved the file, just get the path
      idCardBackPath = file.path;
      console.log('ID Card Back Path:', idCardBackPath);
    } else if (req.body.idCardBack) {
      // Handle base64 image data
      const nationalId = user.personalInformation?.nationalId || 'unknown';
      idCardBackPath = saveBase64Image(
        req.body.idCardBack,
        `${nationalId}-back-${Date.now()}.jpg`,
        'idCardBack'
      );
    }
    
    // Process selfie with ID if provided
    let selfieWithIdPath = null;
    if (req.files && req.files.selfieWithId && req.files.selfieWithId[0]) {
      // Delete old image if it exists
      await deleteOldImages(phone, 'selfieWithId');
      
      // Save new image
      const file = req.files.selfieWithId[0]; // Multer provides an array
      const nationalId = user.personalInformation?.nationalId || 'unknown';
      const fileName = `${nationalId}-selfie-${Date.now()}${path.extname(file.originalname)}`;
      
      // Get the directory for selfie with ID
      const uploadDir = path.join(__dirname, '../../uploads/_idCard_selfie');
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      
      // Multer already saved the file, just get the path
      selfieWithIdPath = file.path;
    } else if (req.body.selfieWithId) {
      // Handle base64 image data
      const nationalId = user.personalInformation?.nationalId || 'unknown';
      selfieWithIdPath = saveBase64Image(
        req.body.selfieWithId,
        `${nationalId}-selfie-${Date.now()}.jpg`,
        'selfieWithId'
      );
    }
    
    // Process signature if provided
    let signaturePath = null;
    if (req.body.signature) {
      // Delete old image if it exists
      await deleteOldImages(phone, 'signature');
      
      // Save the signature as an image
      const nationalId = user.personalInformation?.nationalId || 'unknown';
      signaturePath = saveBase64Image(
        req.body.signature,
        `${nationalId}-signature-${Date.now()}.jpg`,
        'signature'
      );
    }
    
    // Create update object
    const updateData = {};
    
    // Store document paths in the correct structure
    if (idCardFrontPath || idCardBackPath || selfieWithIdPath) {
      updateData.documents = {
        ...(user.documents || {})
      };
      
      if (idCardFrontPath) {
        updateData.documents.idCardFront = {
          url: idCardFrontPath,
          verified: false
        };
      }
      
      if (idCardBackPath) {
        updateData.documents.idCardBack = {
          url: idCardBackPath,
          verified: false
        };
      }
      
      if (selfieWithIdPath) {
        updateData.documents.selfieWithId = {
          url: selfieWithIdPath,
          verified: false
        };
      }
    }
    
    if (signaturePath) updateData.signatureUrl = signaturePath;
    
    // Log the update operation
    console.log('Updating user with ID verification documents:', updateData);
    
    // Update the user document
    user = await User.findByIdAndUpdate(
      user._id,
      updateData,
      { new: true, runValidators: false } // Set runValidators to false to avoid validation errors
    );
    
    res.status(200).json({
      status: 'success',
      data: {
        user: {
          phone: user.phone,
          idCardFrontUrl: user.documents?.idCardFront?.url,
          idCardBackUrl: user.documents?.idCardBack?.url,
          selfieWithIdUrl: user.documents?.selfieWithId?.url,
          signatureUrl: user.signatureUrl
        }
      }
    });
  } catch (error) {
    console.error('Error saving ID verification documents:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to save ID verification documents'
    });
  }
};

// Submit a new loan application
export const submitApplication = async (req, res) => {
  try {
    // We don't require authentication for submission anymore
    // Get all the data from the request body
    const {
      phone,
      // We don't need to extract all fields here since we'll find the user by phone
      // and use the data already saved in the database
    } = req.body;

    // Find the user by phone number
    let user = null;
    try {
      user = await User.findOne({ phone });
      
      if (!user) {
        return res.status(404).json({
          status: 'error',
          message: 'User not found. Please complete the personal information step first.'
        });
      }
      
      // Update the user's status to 'user' (from 'guest' if it was set)
      user = await User.findByIdAndUpdate(
        user._id,
        { role: 'user' },
        { new: true, runValidators: true }
      );
    } catch (err) {
      console.log('Error finding/updating user:', err.message);
      return res.status(500).json({
        status: 'error',
        message: 'Failed to find or update user'
      });
    }

    if (!user) {
      return res.status(500).json({
        status: 'error',
        message: 'Failed to find user'
      });
    }
    
    // Create a loan application record using the data from the user
    const applicationNumber = generateApplicationNumber();

    // Since Prisma might not be fully set up, we'll create a simple application object
    // This is a temporary solution until we fix the Prisma connection
    try {
      // Create a complete application object with all the user's data
      const application = {
        id: Math.random().toString(36).substring(2, 15),
        applicationNumber,
        status: 'SUBMITTED', // Change from DRAFT to SUBMITTED
        createdAt: new Date(),
        submittedAt: new Date(),
        userId: user._id.toString(),
        
        // Personal Information
        personalInformation: user.personalInformation,
        phone: user.phone,
        
        // Address
        address: user.address,
        
        // ID Verification
        idCardFrontUrl: user.idCardFrontUrl,
        idCardBackUrl: user.idCardBackUrl,
        selfieWithIdUrl: user.selfieWithIdUrl,
        signatureUrl: user.signatureUrl,
        
        // Financial Information
        financialInformation: user.financialInformation,
        bankAccount: user.bankAccount,
        
        // Family Contact
        familyContact: user.familyContact
      };
      
      // In a real application, we would save this to a database
      // For now, we'll just return it in the response
      
      res.status(201).json({
        status: 'success',
        data: {
          applicationId: application.id,
          applicationNumber: application.applicationNumber,
          status: application.status,
          submissionDate: application.submittedAt
        }
      });
    } catch (error) {
      console.error('Error creating application:', error);
      res.status(500).json({
        status: 'error',
        message: 'Failed to create loan application'
      });
    }
  } catch (error) {
    console.error('Error submitting loan application:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to submit loan application'
    });
  }
};

// Get user's loan applications
export const getLoanApplications = async (req, res) => {
  try {
    // Check if we have a valid user object
    if (!req.user) {
      return res.status(401).json({
        status: 'error',
        message: 'Authentication required'
      });
    }

    // Handle both MongoDB _id and Prisma id formats
    const userId = req.user._id || req.user.id;
    
    const applications = await prisma.loanApplication.findMany({
      where: {
        userId
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    res.json({
      status: 'success',
      data: applications
    });
  } catch (error) {
    console.error('Error fetching loan applications:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch loan applications'
    });
  }
};

// Save financial information
export const saveFinancialInfo = async (req, res) => {
  try {
    // Get the simplified financial information from the request body
    const { 
      incomeMonthly, 
      employmentStatus, 
      loanPurpose, 
      bankName, 
      accountNumber, 
      accountName, 
      phone
    } = req.body;
    
    // Find user by phone number
    let user = null;
    try {
      user = await User.findOne({ phone });
      
      if (!user) {
        return res.status(404).json({
          status: 'error',
          message: 'User not found'
        });
      }
      
      // Update the user with simplified financial information
      user = await User.findByIdAndUpdate(
        user._id,
        {
          financialInformation: {
            incomeMonthly: incomeMonthly ? parseFloat(incomeMonthly) : 0,
            employmentStatus,
            loanPurpose
          },
          bankAccount: {
            bankName,
            accountNumber,
            accountName
          }
        },
        { new: true, runValidators: true }
      );

      // Log data before updating for debugging
      console.log('Updating loan with data:', {
        userId: user._id,
        incomeMonthly: incomeMonthly ? parseFloat(incomeMonthly) : 0,
        bankName,
        accountNumber,
        accountName,
        employmentStatus,
        loanPurpose
      });
      
      // Also update or create a loan application with this simplified financial data
      try {
        const loanApplication = await mongoose.model('Loan').findOneAndUpdate(
          { user: user._id, status: 'pending' },
          {
            $set: {
              'financialInfo.incomeMonthly': incomeMonthly ? parseFloat(incomeMonthly) : 0,
              'financialInfo.bankName': bankName || '',
              'financialInfo.accountNumber': accountNumber || '',
              'financialInfo.accountName': accountName || '',
              'employmentInfo.employmentStatus': employmentStatus || '',
              'financialInfo.loanPurpose': loanPurpose || ''
            }
          },
          { new: true, upsert: true }
        );
        console.log('Loan application updated successfully:', loanApplication._id);
      } catch (loanErr) {
        console.error('Error updating loan application:', loanErr.message, loanErr.stack);
        // Continue execution even if loan update fails
      }

    } catch (err) {
      console.error('Error finding/updating user or loan:', err.message, err.stack);
      return res.status(500).json({
        status: 'error',
        message: `Failed to update user financial information: ${err.message}`
      });
    }

    // Return the updated user information
    res.status(200).json({
      status: 'success',
      data: {
        user: {
          phone: user.phone
        },
        financialInformation: user.financialInformation,
        bankAccount: user.bankAccount
      }
    });
  } catch (error) {
    console.error('Error saving financial information:', error.message, error.stack);
    res.status(500).json({
      status: 'error',
      message: `Failed to save financial information: ${error.message}`
    });
  }
};

// Save loan details (amount, term, monthly payment)
export const saveLoanDetails = async (req, res) => {
  try {
    // Get the loan details from the request body
    const { amount, term, monthlyPayment, phone } = req.body;
    
    if (!amount || !term || !monthlyPayment) {
      return res.status(400).json({
        status: 'error',
        message: 'Loan amount, term, and monthly payment are required'
      });
    }
    
    // Phone is now required to identify the user
    if (!phone) {
      return res.status(400).json({
        status: 'error',
        message: 'User phone number is required to apply for a loan'
      });
    }
    
    let user = null;
    let loan = null;
    let interestRate = null;
    
    try {
      // Find user by phone number
      user = await User.findOne({ phone });
      
      // If user doesn't exist, return error
      if (!user) {
        return res.status(404).json({
          status: 'error',
          message: 'User not found. You must create an account before applying for a loan.',
          requiresSignup: true
        });
      }
      
      // Find the interest rate for the selected term
      interestRate = await InterestRate.findOne({ 
        term: Number(term),
        isActive: true
      });
      
      // If no interest rate is found, return error
      if (!interestRate) {
        return res.status(404).json({
          status: 'error',
          message: `No interest rate available for term ${term} months. Please select a different term.`
        });
      }
      
      // Look for an existing loan in pending status
      loan = await Loan.findOne({ 
        user: user._id, 
        status: { $in: ['pending'] }
      });
      
      if (loan) {
        // Update existing loan
        loan.amount = Number(amount);
        loan.term = Number(term);
        loan.monthlyPayment = Number(monthlyPayment);
        loan.interestRateRef = interestRate._id;
        loan.appliedRate = interestRate.rate;
        
        await loan.save();
      } else {
        // Create new loan for the user
        loan = new Loan({
          user: user._id,
          amount: Number(amount),
          term: Number(term),
          monthlyPayment: Number(monthlyPayment),
          interestRateRef: interestRate._id,
          appliedRate: interestRate.rate,
          status: 'pending'
        });
        await loan.save();
      }
    } catch (err) {
      console.error('Error finding/updating user or loan:', err.message, err.stack);
      return res.status(500).json({
        status: 'error',
        message: `Error processing loan request: ${err.message}`
      });
    }
    
    // Return the loan details
    res.status(200).json({
      status: 'success',
      data: {
        loanDetails: {
          amount,
          term,
          monthlyPayment
        },
        loan: loan ? {
          id: loan._id,
          status: loan.status
        } : null
      }
    });
  } catch (error) {
    console.error('Error saving loan details:', error.message, error.stack);
    res.status(500).json({
      status: 'error',
      message: `Failed to save loan details: ${error.message}`
    });
  }
};

// Save family contact information
export const saveFamilyContact = async (req, res) => {
  try {
    // Get the family contact information from the request body
    const { familyName, familyPhone, relationship, familyAddress, phone } = req.body;
    
    // Find user by phone number
    let user = null;
    try {
      user = await User.findOne({ phone });
      
      if (!user) {
        return res.status(404).json({
          status: 'error',
          message: 'User not found'
        });
      }
      
      // Update the user with family contact information
      user = await User.findByIdAndUpdate(
        user._id,
        {
          familyContact: {
            familyName,
            familyPhone,
            relationship,
            address: {
              houseNumber: familyAddress.houseNumber,
              subdistrict: familyAddress.subdistrict,
              district: familyAddress.district,
              province: familyAddress.province,
              zipCode: familyAddress.zipCode
            }
          }
        },
        { new: true, runValidators: true }
      );
    } catch (err) {
      console.log('Error finding/updating user:', err.message);
      return res.status(500).json({
        status: 'error',
        message: 'Failed to update user family contact information'
      });
    }

    // Return the updated user information
    res.status(200).json({
      status: 'success',
      data: {
        user: {
          phone: user.phone
        },
        familyContact: user.familyContact
      }
    });
  } catch (error) {
    console.error('Error saving family contact information:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to save family contact information'
    });
  }
};

// Save or update personal information from the first step of loan application
export const savePersonalInfo = async (req, res) => {
  try {
    console.log('Personal Info Request - Method:', req.method);
    console.log('Request body:', JSON.stringify(req.body, null, 2));
    
    // Extract data from request body
    const personalData = req.body;
    
    // Extract personal information fields
    let firstName, lastName, nationalId, dateOfBirth, phone, address;
    
    // Handle nested or flat structure
    if (personalData.personalInformation) {
      firstName = personalData.personalInformation.firstName;
      lastName = personalData.personalInformation.lastName;
      nationalId = personalData.personalInformation.nationalId;
      dateOfBirth = personalData.personalInformation.dateOfBirth;
      address = personalData.personalInformation.address;
      phone = personalData.phone;
    } else {
      firstName = personalData.firstName;
      lastName = personalData.lastName;
      nationalId = personalData.nationalId;
      dateOfBirth = personalData.dateOfBirth;
      address = personalData.address;
      phone = personalData.phone;
    }
    
    // Extract identifiers for checking existing records
    const userId = personalData.userId;
    const originalPhone = personalData.originalPhone;
    const originalNationalId = personalData.originalNationalId;
    
    // Basic validation
    if (!firstName || !lastName || !nationalId || !phone) {
      return res.status(400).json({
        status: 'error',
        message: 'First name, last name, national ID, and phone are required'
      });
    }
    
    console.log('Attempting to find existing user with identifiers:', {
      userId, phone, originalPhone, nationalId, originalNationalId
    });
    
    // Find user by various identifiers in priority order
    let user = null;
    
    try {
      // 1. Try by userId if provided
      if (userId) {
        const mongoose = require('mongoose');
        if (mongoose.Types.ObjectId.isValid(userId)) {
          user = await User.findById(userId);
          if (user) console.log('Found user by ID:', user._id);
        }
      }
      
      // 2. Try by national IDs
      if (!user && nationalId) {
        user = await User.findOne({ 'personalInformation.nationalId': nationalId });
        if (user) console.log('Found user by National ID:', user._id);
      }
      
      if (!user && originalNationalId && originalNationalId !== nationalId) {
        user = await User.findOne({ 'personalInformation.nationalId': originalNationalId });
        if (user) console.log('Found user by original National ID:', user._id);
      }
      
      // 3. Try by phone numbers
      if (!user && phone) {
        user = await User.findOne({ phone });
        if (user) console.log('Found user by phone:', user._id);
      }
      
      if (!user && originalPhone && originalPhone !== phone) {
        user = await User.findOne({ phone: originalPhone });
        if (user) console.log('Found user by original phone:', user._id);
      }
    } catch (err) {
      console.error('Error during user lookup:', err);
      // Continue with the process instead of failing
    }
    
    // Now handle updating or creating the user based on our lookup results
    console.log('User lookup result:', user ? `Found: ${user._id}` : 'Not found - will create new user');
    
    // Prepare the user data for update or creation
    const userData = {
      personalInformation: {
        firstName,
        lastName,
        nationalId,
        dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : undefined
      },
      phone
    };
    
    // Add address if it exists
    if (address) {
      userData.personalInformation.address = {
        subdistrict: address.subdistrict,
        district: address.district,
        province: address.province,
        zipCode: address.zipCode
      };
    }
    
    if (user) {
      // UPDATE EXISTING USER
      try {
        console.log(`Updating existing user: ${user._id}`);
        
        // Update user data
        if (firstName) user.personalInformation.firstName = firstName;
        if (lastName) user.personalInformation.lastName = lastName;
        if (nationalId) user.personalInformation.nationalId = nationalId;
        if (dateOfBirth) user.personalInformation.dateOfBirth = dateOfBirth;
        if (phone) user.phone = phone;
        
        // Update address if provided
        if (address) {
          if (!user.personalInformation.address) {
            user.personalInformation.address = {};
          }
          
          if (address.subdistrict) user.personalInformation.address.subdistrict = address.subdistrict;
          if (address.district) user.personalInformation.address.district = address.district;
          if (address.province) user.personalInformation.address.province = address.province;
          if (address.zipCode) user.personalInformation.address.zipCode = address.zipCode;
        }
        
        // Save the updated user
        await user.save();
        console.log('User successfully updated');
      } catch (error) {
        console.error('Error updating user:', error);
        
        // Handle duplicate key error specifically
        if (error.code === 11000 && error.message.includes('nationalId')) {
          return res.status(400).json({
            status: 'error',
            message: 'This National ID is already used by another user'
          });
        }
        
        return res.status(500).json({
          status: 'error',
          message: 'Failed to update user information'
        });
      }
    } else {
      // CREATE NEW USER
      try {
        console.log('Creating new user with data:', userData);
        const newUser = new User(userData);
        user = await newUser.save();
        console.log('New user created with ID:', user._id);
      } catch (error) {
        console.error('Error creating new user:', error);
        
        // Handle duplicate key error
        if (error.code === 11000 && error.message.includes('nationalId')) {
          return res.status(400).json({
            status: 'error',
            message: 'A user with this National ID already exists'
          });
        }
        
        return res.status(500).json({
          status: 'error',
          message: 'Failed to create new user'
        });
      }
    }
    
    // Send success response to client with the updated/created user information
    if (!user) {
      return res.status(500).json({
        status: 'error',
        message: 'Failed to create or update user record'
      });
    }
    
    // Return success response with user data
    return res.status(200).json({
      status: 'success',
      message: 'Personal information saved successfully',
      data: {
        userId: user._id,
        personalInformation: {
          firstName: user.personalInformation.firstName,
          lastName: user.personalInformation.lastName,
          nationalId: user.personalInformation.nationalId,
          dateOfBirth: user.personalInformation.dateOfBirth
        },
        phone: user.phone
      }
    });
  } catch (error) {
    console.error('Error saving personal information:', error);
    return res.status(500).json({
      status: 'error',
      message: 'Failed to save personal information'
    });
  }
